# Vitis Kernel Based Design Tutorial

---

- [Vitis Kernel Based Design Tutorial](#vitis-kernel-based-design-tutorial)
  - [Introduction](#introduction)
  - [IP development in Vitis HLS](#ip-development-in-vitis-hls)
  - [Generate the Programmable Logic Binary](#generate-the-programmable-logic-binary)
  - [Generate a device tree overlay file](#generate-a-device-tree-overlay-file)
  - [File transfer and directories on the target](#file-transfer-and-directories-on-the-target)
  - [SW development in Python with Jupyter notebooks and Pynq](#sw-development-in-python-with-jupyter-notebooks-and-pynq)
  - [SW development in C++ on the Kria target](#sw-development-in-c-on-the-kria-target)
  - [References](#references)

---
## Introduction
* In this tutorial the kernel based design using an extensible platform is described. It is assumed that an extensible platform is available (for a detailed description how to create such a platform and the sysroot-directory see document [`vitis_extensible_streaming_platform_design.md`](../vitis_tutorials/vitis_extensible_streaming_platform_design.md)). The location of the platform-directory can be anywhere on your computer. It is further assumed that we have a Kria KV260 target with Ubuntu Linux (Version 22.04).

* The design steps are:
  * Develop the IP kernels with Vitis HLS and export them as .xo-files.
  * Build the "hardware" with Vitis v++ compiler (using a bash script), i.e. the bitfile for the programmable logic.
  * Transfer the hardware binary to the Kria target for SW development with Pynq or C/C++ development with Vitis. 
  * Import the "hardware" in Pynq as overlay and write Python SW with Jupyter Notebook running on Kria board.
  * Develop a C/C++ software application in Vitis. 
* The necessary source codes for this tutorial can be found in the repository in the folder `demos > vadd`. Just copy the complete folder and keep the directory structure for this demo project:
  * `dtbo`: Generate the device tree overly here.
  * `hls`: Directory for IP core generation with Vitis HLS.
  * `kria/jupyter_zynq`: Here you can find the Jupyter notebook code which must be transferred to the Kria target.
  * `kria/vadd_sw`: Here you can find a C++ SW project using CMake as build system. The SW will be compiled on the Kria target directly.
  * `system`: This directory will be used for building the PL binary.
* The development described here has been tested with Vivado/Vitis Version 2024.1. Depending on your installation you may have to adapt paths (e.g. paths to the Xilinx installation on your computer) in the scripts etc.

---
## IP development in Vitis HLS
* In this step the IP core is developed with Vitis HLS. The complete source code for the HLS project can be found in the folder `demos > vadd > hls > src`. There is also a bash script `run_hls.sh` in the folder `demos > vadd > hls > project ` which runs the HLS. Execute this script on the command line. Refer also to the tutorial on HLS for explanations to the methodology and the workspace and project setup.
  * The HLS project setup is defined in the file `project.cfg`.
  * The address width of the IP core is be set to 32 Bit in order to be usable with the Pynq Jupyter notebooks. This can be set in the tcl-script with: `config_interface -m_axi_addr64=0`
* Start Vitis and open the directory `vadd/hls` as a workspace. You will  find now the completed synthesis and you can study the results. You may also run `C Simulation` and `C/RTL Cosimulation`, although the code has already been verified. 
* Then run the `Package` step in the flow. The IP Core is exported as .xo-file for the kernel based flow.
  * Note the location of the .xo-file for subsequent steps. It should be in the directory `hls/project/project_work` and is named `krnl_vadd.xo`. 

---
## Generate the Programmable Logic Binary
* In this step the programmable logic part of the project will be generated by using an "extensible platform" and the IP core generated above. Since we only need the PL binary for the Kria target we will do this with a bash script `link_vadd.sh` which you can find in the directory `system`. In the script the v++ compiler is used to link the HLS generated kernel with the extensible platform and generate the PL binary. 
* You can find an extensible platform for all projects under `demos/extensible_platform/kv260_platform.zip`. Unpack the file and store the platform directory on your computer. In the bash script `link_vadd.sh` you may have to adapt the path to the platform file where the extensible platform is stored on your computer.  
* Start the bash script `link_vadd.sh` in a terminal. This may take a while, since a complete Vivado implementation run is performed. When the script has finished you should find two files in the `system` directory:
  * `vadd_hw.xclbin`: This is the PL binary and must be transferred to the Kria target.
  * `vadd_hw.xsa`: This file is needed for the next step.
* The file `vadd_hw.xclbin.info` can be opened with a text editor and gives you some information on the generated hardware, e.g. base addresses and register offsets.


---
## Generate a device tree overlay file 
* Besides the hardware binary a so-called `device tree overlay` (`.dtbo`) file is needed in order to properly load the hardware under Ubuntu Linux on the Kria target. 
* In the folder `dtbo` in the demo you will find a bash-shell-script `create_dtbo.sh` with which you can generate a dtbo-file. Open the script and adjust the path to your Vitis installation. The script calls a second tcl-script `dts.tcl`. In this second script there is a relative path to the xsa-file generated in the step above. Check that this path really points to the xsa-file. Execute the shell script, you should have a device tree overlay file `pl.dtbo`. 

---
## File transfer and directories on the target
* In order to use the FPGA hardware on the target the FPGA binary must be transferred to the correct places in the Ubuntu file system on the target. Since we want to use the hardware with Pynq and also with application SW written in C++ we have to transfer them to three different places:
  * A directory for installation of the FPGA binary ("firmware"). This MUST be a directory in `/lib/firmware/xilinx/` such that the `xmutil` tool can load the binary. Since these directories are owned by `root` you have to use `sudo` for the commands. The directory should be named like the name of the project `/lib/firmware/xilinx/<name>` and has the following content:
    * `pl.dtbo`: Device tree overlay
    * `binary_container_1.bin`: PL binary
    * `shell.json`, a file to be created manually with the following content:

    ```
    {
      "shell_type" : "XRT_FLAT",
      "num_slots": "1"
    }
    ```
  * A project directory for C++ development should be under `/home/ubuntu` for example `/home/ubuntu/projects/<name>` where `<name>` is the name of the project (here `vadd`). 
  * A project directory for Pynq development MUST be under `/home/root/jupyter_notebooks/` for example `/home/root/jupyter_notebooks/projects/<name>`, where `<name>` is the name of the project. Here again `root` is the owner, so you must use `sudo`.
   
* Transfer the binary `vadd_hw.xclbin` and the `pl.dtbo` to the SW project directory `/home/ubuntu/projects/vadd`. Add a `shell.json` file with the content shown above.
* There are bash-scripts available in the directory `demos/scripts` which can be used to setup the directories (`initialize_directories.sh`), copy the files (`copy_xclbin.sh`) and load the HW (`load_app.sh`). The scripts are commented and you may have to change the project name in the scripts. You may also have to make them executable by `chmod a+x *.sh`.
* The transfer of the files from the host computer to the target can be done normally with `sftp` on the host computer. On a Ubuntu Linux host the file manager should be able to work with the `sftp` protocol. You need to find out the IP address of the Kria target in your local network. 
* In order to execute commands or shell scripts on the Kria target you must open a console/terminal (running a `bash` shell) on your Linux host computer and connect to the Kria target via `ssh`. You can use for example the following command: `ssh ubuntu@192.168.178.64` In this case `ubuntu` is the user name on the Kria target and `192.168.178.64` is the IP address. If you do not want to type always the password for login to the target, you can install the `sshpass` utility on your host. Then the command is: `sshpass -p "password" ssh ubuntu@192.168.178.64`, where `password` is the password of the user `ubuntu`. 

---
## SW development in Python with Jupyter notebooks and Pynq
* In the next step of this tutorial we will test the IP core with a SW application written in Python and executed by a Jupyter notebook application running on the Kria target. The Jupyter notebook code can be found in the folder `demos > vadd_extensible_platform > jupyter > vadd_extensible.ipynb`.
* Get the IP address of the Kria board in your network. Copy the Jupyter notebook code `vadd_extensible.ipynb` (e.g. via sftp) first to the home directory on the Kria board (`/home/ubuntu`). Then open a ssh-shell on the Kria board and move the notebook into the path `/home/root/jupyter_notebooks/<name>/` on the Kria board (`/home/root/jupyter_notebooks/` is the root directory for Jupyter notebook project files). Be aware that you may need root-privileges in order to do this.
* The notebook uses Python scripts as modules. Copy the directory `utils` (`demo` directory) to the project directory on the Kria target. 
* The Jupyter notebook application is already running on the Kria board after booting the board and can be accessed via a web browser (`<ip_address>:9090/lab`, Password `xilinx`).
* Open the web browser with the IP address given above. You should find the Jupyter notebook file in the project directory. Open the notebook file and execute it. The notebook code is documented, so we omit any further explanations here. You may have to adapt paths (e.g. the project path).

---
## SW development in C++ on the Kria target
* In this step the application SW which is needed in order to test the IP core will be developed in C++. Normally SW is developed in Vitis and cross-compiled for the Kria target. Another possibility is to compile the SW directly on the target. As an advantage you do not need things like a _sysroot_, if you cross-compile for a Linux target and you do have less problems with incompatible libraries. As a disadvantage compilation times are normally longer on the Kria target, compared to a laptop computer. 
* We use VS Code on our laptop computer and do a remote development via SSH on the Kria target. The methodology is described in the tutorial [vscode_cpp_development](../04_sw_development/vscode_cpp_development.md). In the directory `kria/vadd_sw` you can find the source code and the `CMakeLists.txt` file, which is needed for VS Code. Just copy the directory to the Kria target and open it in VS Code as a workspace.
* Do not forget to load the PL binary (firmware) with the script `load_app.sh` before you execute the SW. 


---
## References
* [Vitis Unified Software Platform Documentation: Application Acceleration Development (UG1393)](https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration)
