# HLS Tutorial 4: Interface Synthesis

---
## Overview
* In this tutorial we would elaborate a bit more on the topic of _Interface Synthesis_. In the previous tutorials we have already covered some interface types like for example _AP_MEMORY_, which generates the ports for Block RAMs in the component. First we have to distinguish between the interface of the C/C++ software function, which are the arguments of the function, and the interface of the generated hardware component, which are basically the ports of the component. In the case of the hardware component we can also talk of an interface, for example when we have a set of ports for attaching a Block RAM memory or a set of ports for a _bus interface_.
* Depending on the type of SW argument there is a default implementation of the HW interface (i.e. the ports) in Vitis HLS. This whole topic is called _Interface Synthesis_ and you can find more information in the [Vitis HLS User Guide](https://docs.amd.com/r/en-US/ug1399-vitis-hls/Introduction-to-Interface-Synthesis). By using directives you can change the default implementation of the interfaces and we will concentrate on this topic in this tutorial.
* We assume that you have completed the previous tutorials and are familiar with Vitis HLS and the GUI concepts and the loop optimization from [tutorial 3](../tutorial_03/tutorial_03.md). 

---
## Setting up the component and baseline synthesis
* Like in the previous tutorials download the folder `tutorial_04/reference_files` and rename this folder to `tutorial_04`. 
* Open a Linux terminal, go to the folder `tutorial_04` and execute the bash script `run_demo.sh`. Then start the Vitis GUI and open the workspace `tutorial_04`.
* First open the component source code `accumulator.c` and study the code.  There is a nested loop which iterates over the number of `CHANNELS` and the number of `SAMPLES` (per channel). For each channel we accumulate the data from the samples with `accu += d_i[j*CHANNELS + i];`. What is important for the following discussion is the fact that we access the data in array `d_i[]` not sequentially but with a constant distance given by `CHANNELS`. 
* Open the testbench code `accumulator_test.c` and study the code. First the input array `d_i[]` is filled with test data, which is simply the value of the loop counter. Then the reference data is generated by a copy of the code in the component. In line 30 the component function is called and finally the output data of the component is compared with the reference data and a final output message is generated. 
* Open the configuration file `sol1_config.cfg` and select the _Source Editor_ view. You can see that we applied already the following directives as explained in [tutorial 3](../tutorial_03/tutorial_03.md) and pipelined the inner loop L1. 

```
syn.compile.enable_auto_rewind=0
syn.compile.pipeline_loops=0
syn.directive.pipeline=accumulator/L1
```

* Next run through the steps in the flow navigator: _C SIMULATION_, _C SYNTHESIS_ and _C/RTL COSIMULATION_. If you want to get more insight how the component function `accumulator` works you can use the debugger in _C SIMULATION_ by pushing the _Debug_ button instead of _Run_.  
* Open the synthesis report and study the results for the performance and resources and the _HW Interfaces_ as shown in the next image. You can see that the loops `L0` and `L1` have been flattened and pipelined (refer to [tutorial 3](../tutorial_03/tutorial_03.md) for more details on loop pipelining). Under the section _HW Interfaces_ you can see that the arrays `d_i[]` and `d_o[]` have been implemented as memory interfaces with the protocol _AP_MEMORY_. 

![Synthesis results](images/hls_100.png)

* In order to get more insight into the memory interfaces you can open the generated VHDL code in the _Vitis Components Explorer_ under `Output > syn > vhdl` as shown in the next image. Here you can see the ports for the memory interfaces. For the array `d_o` these are the address port `d_o_address0` (3 bit since we have 8 elements in the array), the control ports `d_o_ce0` (clock enable) and `d_o_we0` (write enable) and the data port `d_o_d0` (16 bit since the data type for the arrays is `int16_t`). For the array `d_i` we get a similar interface, but without the control port for write enable (since the array is only read) and the data port `d_i_q0` is an input port instead of an output port.

![Ports VHDL](images/hls_101.png)

* In the next image the integration of the IP core in Vivado is shown (refer to [tutorial 1](../tutorial_01/tutorial_01.md) on how to do this). You can see that Block RAMs have been attached to the IP core, where the upper one is attached to the ports for array `d_i[]` and the lower one is attached to the ports for array `d_o[]`. The upper BRAM is configured as ROM, which can be filled with data. The lower one is configured as RAM, where the output port `douta[15:0]` is left open, since we only write to the RAM. Normally this RAM should be configured as _Dual Port RAM_ and the RAM should be read by another component in a system. 

![Vivado project](images/hls_102.png)

## Modifying the protocol for the arrays
* 